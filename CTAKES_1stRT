#Copyright (C) UCSF/Jie Jane Chen/Julian Hong 2025
#GNU General Public License v2.0
#Please see LICENSE and README.md

#load all libraries outside the loop
library(xml2)
library(dplyr)
library(tidyr)
library(stringr)

setwd("/Users/chenj/Downloads/BoneMets_CTCAE")
output_path = "/Users/chenj/Downloads/BoneMets_CTCAE"

# import csv file with snomed concepts extracted from cdw 
snomed_concepts <- read.csv("./Symptoms_dxRT_RT1st.csv", header = TRUE)
save(snomed_concepts, file="snomed_concepts_RT_1st course.rda")
load("./snomed_concepts_RT_1st course.rda")

colnames(snomed_concepts)[colnames(snomed_concepts) == 'vocab_term_id'] <- 'code'
colnames(snomed_concepts)[colnames(snomed_concepts) == 'notekey'] <- 'NOTE_ID'
colnames(snomed_concepts)[colnames(snomed_concepts) == 'canon_text'] <- 'preferredText'
colnames(snomed_concepts)[colnames(snomed_concepts) == 'domain'] <- 'textsem'
colnames(snomed_concepts)[colnames(snomed_concepts) == 'negated'] <- 'polarity'

colnames(snomed_concepts)[colnames(snomed_concepts) == 'ptkey'] <- 'ptkey'
colnames(snomed_concepts)[colnames(snomed_concepts) == 'dxdate'] <- 'dxdate'
colnames(snomed_concepts)[colnames(snomed_concepts) == 'RTstart'] <- 'RTstart'
colnames(snomed_concepts)[colnames(snomed_concepts) == 'sx_date'] <- 'sx_date'
colnames(snomed_concepts)[colnames(snomed_concepts) == 'diff_days_sxRT'] <- 'diff_days_sxRT'

# if negated = false, set to a 1 otherwise set to -1 
snomed_concepts$polarity[snomed_concepts$polarity==1] <- -1
snomed_concepts$polarity[snomed_concepts$polarity==0] <- 1

# if domain is "signs and symptoms set to ssx" if domain is disease set to "dis"
snomed_concepts$textsem[snomed_concepts$textsem=='signs and symptoms'] <- 'ssx'

#import the vocabulary file from OHDSI Athena
concept_relationships <- read.table("./CONCEPT_RELATIONSHIP.csv", sep = "\t", dec = ".", header = TRUE,
                                    encoding = "UTF-8", stringsAsFactors = FALSE, quote = "")

#concept file 
concepts <- read.table("./CONCEPT.csv", sep = "\t", dec = ".", header = TRUE, fill = TRUE,
                       encoding = "UTF-8", stringsAsFactors = FALSE, quote = "")

#now separate out the SNOMED and MedDRA codes
snomed <- filter(concepts, vocabulary_id == "SNOMED")
meddra <- filter(concepts, vocabulary_id == "MedDRA")

#Generate the map to connect SNOMED and MedDRA codes 
map <- filter(concept_relationships, relationship_id == "SNOMED - MedDRA eq")
temp <- map %>%
  left_join(snomed, by = c("concept_id_1" = "concept_id")) %>%
  left_join(meddra, by = c("concept_id_2" = "concept_id"))

#verified join and cleanup
map <- temp
rm(temp)
rm(snomed)
rm(meddra)

#convert to characters
map$concept_code.x <- as.character(map$concept_code.x)
map$concept_code.y <- as.character(map$concept_code.y)

map <- map %>%  
  mutate(concept_code.x = as.numeric(concept_code.x))

#now let's join our notes on snomed codes
temp <- left_join(snomed_concepts, map, by = c("code" = "concept_code.x"))

#convert this to a long form by individual concepts on meddra codes 
#PUT EVERY COLUMN THAT'S NOT IN THE GROUP_BY in the summarize row
library(tidyr) #v1.0.0
ctakeslong <-
  temp %>%
  select(ptkey, dxdate, RTstart, sx_date, diff_days_sxRT, NOTE_ID, concept_code.y, polarity, preferredText, textsem, concept_name.y) %>%
  group_by(ptkey, NOTE_ID, concept_code.y) %>%
  summarize(polarity = max(as.numeric(as.character(polarity))), firstsnomed = first(preferredText), firstsem = first(textsem), meddra = first(concept_name.y), firstdxdate = first(dxdate), firstRTstart = first(RTstart), firstsx_date = first(sx_date), firstdiff_days_sxRT = first(diff_days_sxRT))

#let's now take a look at concepts that were not mapped to Meddra to identify potential missed symptoms (none were symptoms)

ctakes_notMeddra <-
  ungroup(ctakeslong) %>%
  filter(is.na(concept_code.y)) %>%
  select(firstsnomed, firstsem) %>%
  group_by(firstsnomed) %>%
  summarize(sem = first(firstsem), num = n())

summary(as.factor(ctakes_notMeddra$sem))

###
#There are relevant extracted MEDDRA codes that weren't in the CTCAE term dictionary.
#Let's take a look at those and get a plaintext explanation for them
#CTCAE is from the NCI https://ctep.cancer.gov/protocolDevelopment/electronic_applications/ctc.htm (v5)

# import CTCAE codes
ctcae <- read.csv("./CTCAE_CODES.csv", check.names = FALSE, stringsAsFactors = FALSE)
ctcaecol = colnames(ctcae)
rm(ctcae)

# unique meddra codes related to concepts in given set of notes 
ctakescol <- unique(na.omit(ctakeslong$concept_code.y))

# filter for meddra concepts not included in ctcae
ctakesnotctcae <-
  as.data.frame(setdiff(ctakescol, ctcaecol)) %>%
  left_join(map, by = c("setdiff(ctakescol, ctcaecol)" = "concept_code.y"))

#this will require a ctakes dictionary which we can build off of ctakeslong (which contains all of the ctakes codes mapped to Meddra)
#let's compile a list to see if their synonyms are mapped already
ctakesterms <-
  ctakeslong %>%
  filter(!is.na(concept_code.y)) %>%
  group_by(concept_code.y) %>%
  summarize(firstsem = first(firstsem), meddra = first(meddra), num = n())

ctakesterms$CTCAE[ctakesterms$concept_code.y %in% ctcaecol] <- 1 #1 if yes, 0 if not in CTCAE
ctakesterms$CTCAE[!(ctakesterms$concept_code.y %in% ctcaecol)] <- 0 #1 if yes, 0 if not in CTCAE

sum(ctakesterms$CTCAE) #output out the # in CTCAE for reference

#Thesaurus to convert these terms and consolidate with CTCAE
thesaurus <- read.csv("BoneMets_Thesaurus.csv", check.names = FALSE, stringsAsFactors = FALSE, colClasses = rep("character", 5))

#let's make some changes to ctakes long
#we want to basically convert the existing codes if they are in our thesaurus from meddra to ctcae
ctakeslongsyn <- left_join(ctakeslong, thesaurus, by = c("concept_code.y" = "concept_code"))

#anything with a synonym should overwrite concept_code.y
#create a ctakes long analog which has the new features; should be the same length as all detected concept-codes
ctakeslongsyn$concept_code.y[!is.na(ctakeslongsyn$synonymcode)] <- ctakeslongsyn$synonymcode[!is.na(ctakeslongsyn$synonymcode)]

ctakeslongsyn <- #this part will shorten us down to < original by collapsing codes
  ctakeslongsyn %>%
  select(colnames(ctakeslong)) %>%
  group_by(ptkey, NOTE_ID, concept_code.y) %>%
  summarize(polarity = max(as.numeric(as.character(polarity))), firstsnomed = first(firstsnomed), firstsem = first(firstsem), meddra = first(meddra), dxdate = first(firstdxdate), RTstart = first(firstRTstart), sx_date = first(firstsx_date), diff_days_sxRT = first(firstdiff_days_sxRT))

ctakeslongsyn$ctcae[ctakeslongsyn$concept_code.y %in% ctcaecol] <- 1 #1 if yes, 0 if not in CTCAE
ctakeslongsyn$ctcae[!(ctakeslongsyn$concept_code.y %in% ctcaecol)] <- 0 #1 if yes, 0 if not in CTCAE

# filter for only ctcae concepts 
ctakeslongsyn <- 
  ctakeslongsyn %>%
  filter(!(ctcae==0))

# save output in long form with all ctcae terms that appeared in given set of notes 
ctakeslongsyn <- ctakeslongsyn[,!names(ctakeslongsyn) %in% c("ctcae")]
write.csv(ctakeslongsyn, paste(output_path,"ctcaelong.csv",sep = ""))

#now we need to add in all the other missing symptoms that were not detected though via cTakes
#it's also OK to eliminate those codes without CTCAE mapping at this point but let's take a look and see what they are now.
#Make sure any meaningful symptoms with > 1 mention are coded
#This counts distinct # of patients with each term, does not tell us if negated or not
temp <-
  ctakeslongsyn %>%
  filter(!is.na(concept_code.y)) %>%
  group_by(concept_code.y) %>%
  summarize(meddra = first(meddra), distinct_ptnum = n_distinct(ptkey))
temp$ctcae[temp$concept_code.y %in% ctcaecol] <- 1 #1 if yes, 0 if not in CTCAE
temp$ctcae[!(temp$concept_code.y %in% ctcaecol)] <- 0 #1 if yes, 0 if not in CTCAE

write.csv(temp, paste(output_path,"ctakestermspostmap_pts.csv",sep=""))
rm(temp)

#This counts distinct # of notes with each term, does not tell us if negated or not
temp <-
  ctakeslongsyn %>%
  filter(!is.na(concept_code.y)) %>%
  group_by(concept_code.y) %>%
  summarize(meddra = first(meddra), num = n())
temp$ctcae[temp$concept_code.y %in% ctcaecol] <- 1 #1 if yes, 0 if not in CTCAE
temp$ctcae[!(temp$concept_code.y %in% ctcaecol)] <- 0 #1 if yes, 0 if not in CTCAE

write.csv(temp, paste(output_path,"ctakestermspostmap_notes.csv",sep=""))
rm(temp)

#now convert to wide form and one-hot encoding of all 837 CTCAE terms 
ctakes <-
  select(ctakeslongsyn, ptkey, NOTE_ID, dxdate, RTstart, sx_date, diff_days_sxRT, concept_code.y, polarity) %>%
  spread(concept_code.y, polarity)

ctakescol <- colnames(ctakes) #reset the column names here

#now we want to set all CTCAE codes that are present 
temp <-ctakes[, append('NOTE_ID', intersect(ctcaecol, ctakescol))]

#fill those in with 0s now
temp[is.na(temp)] <- 0

# save wide version with only subset of CTCAE codes that were mapped to MedDRA code in the given group of notes 
write.csv(temp, paste(output_path,"ctcaewide_mapped.csv",sep=""))

#so what are we missing
missing <- setdiff(ctcaecol, ctakescol)

#now we have to read in the columns that were in the original dataframe though
#make a new 0 matrix
add <- matrix(0L, nrow = nrow(temp), ncol = length(missing))
colnames(add) <- missing
ctcaewide <- cbind(as.data.frame(temp), add, stringsAsFactors = FALSE)

#we have to do the same thing for rows which should be easy with a left join to resort
ctcaewide$NOTE_ID <- as.factor(ctcaewide$NOTE_ID)

#fill those in with 0s now
ctcaewide[is.na(ctcaewide)] <- 0

#write out the ctcaewide output file
write.csv(ctcaewide, paste(output_path,"ctcaewide_all.csv",sep=""))
